"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConversation = exports.comp4Test = exports.parseSpeakerLine = void 0;
/* eslint-disable eqeqeq */
/* eslint-disable prefer-destructuring */
/* eslint-disable no-param-reassign */
// https://drive.google.com/drive/u/0/folders/1L_apLy2bakDweL-PWcay807_rJdxQxyR
function parseSpeakerLine(line) {
    var text = line.trim();
    // capture opening timestamp - "[00:00]"", "1:10" ...
    var value = {
        weak: true,
        preTime: false,
        speaker: '',
        speaker_end: 0,
        time: false,
        timestamp: undefined,
        timestamp_full_match_string: undefined,
        separator: false,
        hasText: false,
        text: undefined,
    };
    /// /////////////////////////////////////////////////
    // extracting timestamp from text
    var matchArea = text.substring(0, Math.min(text.length, 40));
    var colonPos = matchArea.indexOf(':');
    var timestampFound = getTimestamp(matchArea, value);
    var signatureEndPos = 0;
    if (timestampFound) {
        // validate timestamp position
        // if (value.timestamp_position > 40) return false; // too far into the text
        if (colonPos !== -1 && colonPos < value.timestamp_position) {
            timestampFound = false;
            value.time = false;
            value.timestamp = undefined;
        }
        else {
            // check if pre/after
            if (value.timestamp_position === 0) {
                value.preTime = true;
            }
            // remove timestamp from text for further processing
            text = text.replace(value.timestamp_full_match_string, '');
            matchArea = matchArea.replace(value.timestamp_full_match_string, '');
            signatureEndPos = value.timestamp_full_match_string.length;
        }
    }
    /// /////////////////////////////////////////////////
    // check if speaker only, in all caps - WEAK PATTERN
    var match = (timestampFound)
        ? text.match(/^[ A-Za-z_-]{3,20}$/) // include lowercase
        : text.match(/^[ A-Z_-]{3,20}$/);
    if (match != null) {
        value.weak = !timestampFound;
        value.speaker = match[0].trim();
        // end position for speaker signature area (for highlighting),
        // use match[0].length to include whitespace
        value.speaker_end = match[0].length + signatureEndPos;
        value.hasText = false;
        return value;
    }
    // update colon position after timestamp removal
    if (timestampFound)
        colonPos = matchArea.indexOf(':');
    if (colonPos === -1 && !timestampFound)
        return null; // failed to fing signature
    if (colonPos === -1) { // only timestamp
        if (text.length !== 0)
            return null; // if text after timestamp, fail
        value.weak = true; // weak only if no timestamp is found
        value.speaker = 'Speaker';
        value.speaker_end = signatureEndPos;
        value.hasText = false;
    }
    value.separator = true;
    // if no whitespace after speaker, fail same line text
    var textPos = colonPos + 1;
    value.hasText = textPos < text.trimEnd().length - 1;
    if (value.hasText && ' \t\n\r\v'.indexOf(text[textPos]) === -1) {
        return null;
    }
    value.weak = false;
    value.text = value.hasText ? text.substring(textPos).trim() : null;
    value.speaker = text.substring(0, colonPos).trim();
    value.speaker_end = signatureEndPos + colonPos;
    return value;
}
exports.parseSpeakerLine = parseSpeakerLine;
function isEmptyOrWhitespace(_string1) {
    return (_string1 == null || _string1.length === 0 || !_string1.trim());
}
function comp(a, b) {
    return a.time === b.time && a.hasText === b.hasText
        && a.separator === b.separator && a.preTime === b.preTime;
}
function comp4Test(a, b) {
    if ((a == null) !== (b == null))
        return false;
    if (a == null)
        return b == null;
    return a.speaker == b.speaker
        && a.hasText == b.hasText
        && a.separator == b.separator
        && a.preTime == b.preTime
        && a.text == b.text
        && a.weak == b.weak
        && (!(a.timestamp || b.timestamp) || a.timestamp == b.timestamp);
}
exports.comp4Test = comp4Test;
function indexOfGroup(match, n) {
    var ix = match.index;
    for (var i = 1; i < n; i++) {
        if (match[i])
            ix += match[i].length;
    }
    return ix;
}
function getTimestamp(text, value) {
    var match = null;
    // match preceding timestamp "[3:07 PM, 3/15/2022] Adam Hanft: Helps"
    match = text.match(/(^\s*\[?\s*)([0-9:,\sPAM/]{4,23})(\]?)\s*/);
    if (match != null && (match[3] || match[0].indexOf('/') !== -1)) { // match found + either  [ ] or /2/
        value.preTime = true;
        value.weak = false;
        value.time = true;
        value.timestamp = match[2].trim();
        value.timestamp_position = indexOfGroup(match, 2);
        value.timestamp_full_match_string = match[0];
        return true;
    }
    //                  optinal      [        timestamp                 ]  \s*
    match = text.match(/(^\s*)?(\[?)(\d{1,2}:\d{1,2})(:\d{1,2})?(\.\d*)?(\]?\s*)/);
    if (match != null) { // && match[0] != ":"
        value.weak = false;
        value.time = true;
        value.timestamp_position = match.index;
        value.timestamp_full_match_string = match[0];
        // capture timestamp without non-captured groups
        value.timestamp = text.substring(indexOfGroup(match, 3), indexOfGroup(match, 6)).trim();
        return true;
    }
    return false;
}
// version 1.6.1
// strict=true enforces the same speaker format pattern across all lines/
// struct=false only enforces that all lines HAVE a valid speaker pattern
function parseConversation(text, strict) {
    if (strict === void 0) { strict = false; }
    var result = [];
    // Trying to parse as SRT format
    var strRegex = /\d+\n\d{1,2}:\d{2}:\d{2}[,.]\d{1,3} --> \d{1,2}:\d{2}:\d{2}[,.]\d{1,3}/;
    var match = text.match(strRegex);
    if (match != null) {
        var dataArray = text.split(strRegex);
        dataArray.shift(); // remove first empty line in array
        for (var i = 0; i < dataArray.length; i += 1) {
            result.push({
                speaker: 'Speaker',
                utterance: dataArray[i].trim().replace('\n', ' '),
            });
        }
        return result;
    }
    // return {"error":"SRT detected","line":0, "format":"SRT"};
    var lines = text.split(/\r?\n/);
    var firstLine = true;
    var structure = null;
    var currentLineInfo = null;
    var waitForTextLine = false;
    //   let weak = false;
    var previousObject = null;
    lines.forEach(function (line, i) {
        // ignore empty prefix lines
        if (isEmptyOrWhitespace(line))
            return;
        // parse first line to ascertain structure
        if (waitForTextLine) {
            previousObject.utterance = line.trim();
            // previousObject.text_line = i;
            waitForTextLine = false;
            return;
        }
        currentLineInfo = parseSpeakerLine(line);
        // if no speaker format detected, fail
        if (currentLineInfo == null) {
            if (firstLine)
                throw new Error('no_speaker_pattern', { line: i });
            previousObject.utterance += "\n".concat(line.trim());
            //   weak = true;
            return;
        }
        if (firstLine)
            structure = parseSpeakerLine(line);
        // weak |= currentLineInfo.weak;
        // parse new speaker line, if structure differs, fail parsing
        if (strict && !comp(structure, currentLineInfo)) {
            throw new Error('differing_pattern', { line: i });
        }
        firstLine = false;
        previousObject = __assign({ speaker: currentLineInfo.speaker, utterance: currentLineInfo.text || '' }, (currentLineInfo.timestamp && { timestamp: currentLineInfo.timestamp }));
        result.push(previousObject);
        waitForTextLine = !currentLineInfo.hasText;
    });
    if (previousObject != null && isEmptyOrWhitespace(previousObject.utterance)) {
        result.pop();
    }
    // if (waitForTextLine)  return {"error":"last_utterance_empty","line":i};
    // if any weak line detected
    // if (weak && result.length <=2) return {"error":"weak_pattern_not_long_enough","line":i};
    return result;
}
exports.parseConversation = parseConversation;
