"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildClusteringQueryParams = exports.buildClusteringItems = exports.buildAsyncApiResponse = exports.buildError = exports.buildOutput = exports.buildRequest = void 0;
/* istanbul ignore file */
var axios_1 = __importDefault(require("axios"));
var classes_1 = require("../classes");
var errors_1 = require("../errors");
function buildRequest(input, skills, includeText) {
    var fixedInput = ((0, classes_1.isFileContent)(input.text) && includeText)
        ? {
            text: input.text.buffer.toString(input.encoding),
            encoding: input.encoding,
            contentType: input.contentType,
            type: input.type,
        } : input;
    return JSON.stringify(__assign(__assign({}, (includeText && { input: fixedInput.text })), { input_type: fixedInput.type, output_type: 'json', encoding: fixedInput.encoding, content_type: fixedInput.contentType, steps: skills.map(function (skill) { return ({
            skill: skill.apiName,
            params: skill.params,
        }); }) }), function (_, value) { return value !== null && value !== void 0 ? value : undefined; });
}
exports.buildRequest = buildRequest;
var pattern = /(\d+):(\d+):(\d+).(\d+)/;
function timestampToMilliseconds(timestamp) {
    if (!timestamp)
        return undefined;
    var match = timestamp.match(pattern);
    if (!match)
        return undefined;
    var numbers = match.map(function (n) { return parseInt(n, 10); });
    var _a = __read(numbers, 5), hour = _a[1], minute = _a[2], second = _a[3], milli = _a[4];
    return (((hour * 60 + minute) * 60 + second)) * 1000 + milli;
}
var buildLabel = function (label) { return (__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, label.skill && { skill: label.skill }), label.type && { type: label.type }), label.name && { name: label.name }), label.span && { span: label.span }), label.span_text && { spanText: label.span_text, span_text: label.span_text }), label.output_spans && { outputSpans: label.output_spans }), label.input_spans && { inputSpans: label.input_spans }), label.value && { value: label.value }), label.timestamp && { timestamp: timestampToMilliseconds(label.timestamp) }), label.timestamp_end && { timestampEnd: timestampToMilliseconds(label.timestamp_end) }), { data: label.data || {} })); };
function buildOutputBase(contents, stats, headers) {
    return {
        text: (contents.length > 1 || 'speaker' in contents[0])
            ? contents
            : contents[0].utterance,
        requestId: headers === null || headers === void 0 ? void 0 : headers['x-oneai-request-id'],
        stats: (headers !== undefined) ? {
            concurrencyWaitTime: stats === null || stats === void 0 ? void 0 : stats.concurrency_wait_time,
            totalRunningJobs: stats === null || stats === void 0 ? void 0 : stats.total_running_jobs,
            totalWaitingJobs: stats === null || stats === void 0 ? void 0 : stats.total_waiting_jobs,
            wordCount: parseInt(headers === null || headers === void 0 ? void 0 : headers['x-oneai-word-count'], 10),
            transcriptionSecondsCount: parseInt(headers === null || headers === void 0 ? void 0 : headers['x-oneai-transcribe-seconds-count'], 10),
        } : undefined,
    };
}
function buildOutput(steps, output, headers) {
    function splitPipeline(skills, i) {
        // split pipeline at a generator Skill
        var first = skills.slice(0, i + 1);
        var second = skills.slice(i + 1);
        if (skills[i].labelsField) {
            // handle skills that create both text and labels
            var clone = __assign({}, skills[i]);
            clone.textField = undefined;
            second.unshift(clone);
        }
        return [first, second];
    }
    function build(outputIndex, skills, includeStats) {
        var source = output.output[outputIndex];
        var result = (includeStats)
            ? buildOutputBase(source.contents, output.stats, headers)
            : buildOutputBase(source.contents);
        var labels = source.labels.map(buildLabel);
        skills.some(function (skill, i) {
            if (skill.textField) {
                var _a = __read(splitPipeline(skills, i), 2), nextSkills_1 = _a[1];
                result[skill.textField] = build(outputIndex + 1, nextSkills_1, false);
                return true;
            }
            result[skill.labelsField || skill.apiName] = labels.filter(function (label) { return label.skill === skill.apiName; });
            return false;
        });
        return result;
    }
    var generator = (output.output[0].text_generated_by_step_id || 0) - 1;
    if (generator < 0)
        return build(0, steps, true);
    // edge case- first Skill is a generator, or a generator preceded by
    // Skills that didn't generate output. In this case the API will skip these Skills,
    // so we need to create filler objects to match the expected structure
    var _a = __read(splitPipeline(steps, generator), 2), currentSkills = _a[0], nextSkills = _a[1];
    var result = buildOutputBase(output.input, output.stats, headers);
    currentSkills.forEach(function (skill) {
        if (skill.textField) {
            result[skill.textField] = build(0, nextSkills, false);
        }
        else {
            result[skill.labelsField || skill.apiName] = [];
        }
    });
    return result;
}
exports.buildOutput = buildOutput;
function buildError(error) {
    var _a, _b, _c, _d;
    if (axios_1.default.isAxiosError(error) && error.response !== undefined) {
        return new errors_1.httpStatusErrorType[error.response.status.toString()](((_a = error.response.data) === null || _a === void 0 ? void 0 : _a.status_code) || error.response.status, ((_b = error.response.data) === null || _b === void 0 ? void 0 : _b.message) || error.message, (_c = error.response.data) === null || _c === void 0 ? void 0 : _c.details, (_d = error.response.data) === null || _d === void 0 ? void 0 : _d.request_id);
    }
    if (typeof error === 'object' && 'status_code' in error) {
        return new errors_1.httpStatusErrorType[error.status_code.toString().substring(0, 3)](error.status_code, error.message, error.details, error.request_id);
    }
    return error;
}
exports.buildError = buildError;
function buildAsyncApiResponse(task, response, headers) {
    var result;
    if (response.status === 'COMPLETED') {
        result = buildOutput(task.skills, response.result, headers);
    }
    else if (response.status === 'FAILED') {
        result = buildError(response.result);
    }
    return __assign(__assign({}, task), { status: response.status, result: result });
}
exports.buildAsyncApiResponse = buildAsyncApiResponse;
function buildClusteringItems(inputs, forceNewClusters, forceClusterId) {
    return inputs.map(function (input) { return (__assign(__assign({ text: input.text, item_metadata: input.metadata }, forceNewClusters && { 'force-new-cluster': forceNewClusters }), forceClusterId && { 'force-cluster-id': forceClusterId })); });
}
exports.buildClusteringItems = buildClusteringItems;
function buildClusteringQueryParams(params) {
    var urlParams = new URLSearchParams();
    var fromDate = (typeof (params === null || params === void 0 ? void 0 : params.fromDate) === 'string') ? new Date(params === null || params === void 0 ? void 0 : params.fromDate) : params === null || params === void 0 ? void 0 : params.fromDate;
    var toDate = (typeof (params === null || params === void 0 ? void 0 : params.toDate) === 'string') ? new Date(params === null || params === void 0 ? void 0 : params.toDate) : params === null || params === void 0 ? void 0 : params.toDate;
    urlParams.set('include-items', 'false');
    urlParams.set('include-phrases', 'false');
    if ((params === null || params === void 0 ? void 0 : params.sort) !== undefined)
        urlParams.set('sort', params.sort);
    if ((params === null || params === void 0 ? void 0 : params.limit) !== undefined)
        urlParams.set('limit', params.limit.toString());
    if (fromDate !== undefined)
        urlParams.set('from-date', fromDate.toISOString());
    if (toDate !== undefined)
        urlParams.set('to-date', toDate.toISOString());
    if ((params === null || params === void 0 ? void 0 : params.itemMetadata) !== undefined)
        urlParams.set('item-metadata', params.itemMetadata);
    return urlParams.toString();
}
exports.buildClusteringQueryParams = buildClusteringQueryParams;
